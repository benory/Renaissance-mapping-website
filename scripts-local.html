{% include_relative scripts-listeners.html %}

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
	     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
	     crossorigin=""/>

<script>

let events = {% include metadata/Events.json %};


//////////////////////////////
//
// buildLookupTables –- 
//

function buildLookupTables() {
	let metadata = MAP.METADATA;
	if (!metadata){
		console.warn("No METADATA!");
		return;
	}
	for (sheet in metadata) {
		if (sheet === "Events"){
			continue;
		}
		buildLookupTable(sheet);
	}
}


//////////////////////////////
//
// buildLookupTable –-
//

function buildLookupTable(sheet) {
    let sheetArray = MAP.METADATA[sheet];
    if (!sheetArray || !Array.isArray(sheetArray)){
        console.warn("No METADATA FOR", sheet);
        return;
    }
    MAP.lookup[sheet] = {};
    const lookup = MAP.lookup[sheet];

    // Dynamically determine the ID key
    let idKey = null;
    if (sheetArray.length > 0) {
        const firstEntry = sheetArray[0];
        for (let key in firstEntry) {
            if (key.toLowerCase().includes("id")) {
                idKey = key;
                break;
            }
        }
    }

    if (!idKey) {
        console.warn(`No ID key found for sheet ${sheet}`);
        return;
    }

    for (let entry of sheetArray) {
        let id = entry[idKey];
        if (!id){
            console.warn("NO ID FOR ENTRY", entry);
            continue;
        }
        lookup[id] = entry;
    }
}

//////////////////////////////
//
// findInfo –- find info on other sheets
//

function findInfo(id, sheet) {
    return MAP.lookup[sheet] ? MAP.lookup[sheet][id] : null;
}

//////////////////////////////
//
// doMapSetup –- Function to setup the map and add markers
//

function doMapSetup(opts) {
    if (typeof opts === "undefined") {
        console.error("doMapSetup input parameter is undefined");
        return;
    }
    if (typeof opts.name === "undefined") {
        console.error("doMapSetup name parameter is undefined");
        return;
    }
    if (typeof opts.view === "undefined") {
        console.error("view option is not specified");
        return;
    }
    if (typeof opts.zoom === "undefined") {
        console.warn("zoom option is not specified, setting to 4");
        opts.zoom = 5;
    }
    if (typeof opts.zoomMin === "undefined") {
        console.warn("zoomMin option is not specified, setting to zoom");
        opts.zoomMin = opts.zoom;
    }
    if (typeof opts.zoomMax === "undefined") {
        console.warn("zoomMax option is not specified, setting to 19");
        opts.zoomMax = 19;
    }

    if (map) {
        map.eachLayer(function(layer) {
            map.removeLayer(layer);
        });
        map.remove();
    }

    map = L.map(opts.name).setView(opts.view, opts.zoom);
    map.options.minZoom = opts.zoomMin;

    let mapImage = "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    let attribution = "&copy; <a href='http://www.openstreetmap.org/copyright'>OpenStreetMap</a>";
    L.tileLayer(mapImage, {
        maxZoom: opts.zoomMax,
        attribution: attribution
    }).addTo(map);

    // Get names of variables
    let ID = MAP.cindex("EV", "EVID");
    let LOC = MAP.cindex("EV", "LOCID");
    let BIOID = MAP.cindex("EV", "BIOID");
    let EINFO = MAP.cindex("EV", "EINFO");
    let DATERANGE = MAP.cindex("EV", "DATERANGE");
    let LOCID = MAP.cindex("LOC", "LOCID");
    let LOCNAME = MAP.cindex("LOC", "LOCNAME");
    let LOCCITY = MAP.cindex("LOC", "CITY");
    let COORD = MAP.cindex("LOC", "COORD");
    let BCONAME = MAP.cindex("BCO", "BCONAME");
    let BMUNAME = MAP.cindex("BMU", "BMUNAME");
    let BNONAME = MAP.cindex("BNO", "BNONAME");

    // Get variable names for certainty markers
    let CERTLOC = MAP.cindex("EV", "CERTLOC");
    let CERTEDATE = MAP.cindex("EV", "CERTEDATE");
    let CERTLDATE = MAP.cindex("EV", "CERTLDATE");
    let CERTRANGE = MAP.cindex("EV", "CERTRANGE");

    // Get variable names for document entries
    let DOEID = MAP.cindex("EV", "DOEID");
    let ARDID = MAP.cindex("DOE", "ARDID");
    let ARDARC = MAP.cindex("ARD", "ARC");
    let ARDARCFOND = MAP.cindex("ARD", "ARCFOND");
    let ARDSIG = MAP.cindex("ARD", "SIG");

    // Establish variables
    let eventid = "";
    let person = "";
    let personprocessed = "";
    let locationid = "";
    let locationprocessed = "";
    let largerlocation = "";
    let daterange = "";
    let coordinates = "";
    let coordinatesprocessed = "";
    let description = "";
    let docentry = "";
    let bibliography = "";
    let archiveprocessed = "";

    markers = []; // Clear the markers array

    for (let i = 0; i < events.length; i++) {
        
        // Only process events for map if there's a location and a date
        if (events[i][LOC] && events[i][DATERANGE]) {
            eventid = events[i][ID];
            locationid = events[i][LOC];
            let locationInfo = findInfo(locationid, "Locations");
            locationprocessed = locationInfo[LOCNAME];

            // Find larger location, if applicable
            let largerlocation = locationInfo[LOCCITY];
            if (largerlocation) {
                locationprocessed += `, ${largerlocation}`;
            }

            // Get name of person
            if (events[i][BIOID]) {
                person = events[i][BIOID];
                let composerInfo = findInfo(person, "Bio_Composers");
                let musicianInfo = findInfo(person, "Bio_Musicians");
                let nonmusicianInfo = findInfo(person, "Bio_Nonmusicians");

                // Get first three letters to determine type of ID
                let nameshort = person.substring(0, 3);

                // Get name from composer, musician, or non-musician biography sheets
                if (nameshort === "BCO" && composerInfo) {
                    personprocessed = composerInfo[BCONAME];
                } else if (nameshort === "BMU" && musicianInfo) {
                    personprocessed = musicianInfo[BMUNAME];
                } else if (nameshort === "BNO" && nonmusicianInfo) {
                    personprocessed = nonmusicianInfo[BNONAME];
                } else {
                    continue;
                }
            }

            // Get dates
            if (events[i][DATERANGE]) {
                daterange = events[i][DATERANGE];
            }

            // Get event description
            if (events[i][EINFO]) {
                description = events[i][EINFO];
            }

            // Get certainty information
            let locationCertainty = events[i][CERTLOC];
            let earliestDateCertainty = events[i][CERTEDATE];
            let latestDateCertainty = events[i][CERTLDATE];
            let rangeCertainty = events[i][CERTRANGE];

            // Add information about location certainty to location
            // Only consider location certainty if not certain
            // Return a console message if the location certainty is not 1, 2, 3, or 4
            if (locationCertainty && locationCertainty !== "1"){
                if (locationCertainty === "2"){
                    locationprocessed += ` [probable]`;
                } else if (locationCertainty === "3"){
                    locationprocessed += ` [possible]`;
                } else if (locationCertainty === "4"){
                    locationprocessed += ` [doubtful]`;
                } else {
                    console.warn("Forbidden location certainty for", eventid, locationCertainty);
                    continue;
                }
            }

            // Get archival signature for linked document entry, if applicable
            if (events[i][DOEID]) {
                docentry = events[i][DOEID];
                let archivalid = "";

                // Split docentries if multiple documents separated by a semicolon
                if (docentry.match(";")){
                    docentry = docentry.trim().split(/\s*;\s*/);
                } else {
                    docentry = [ docentry ];
                }
                
                for (let j=0; j<docentry.length; j++){
                    // Get archival document from document entries data
                    let documentInfo = findInfo(docentry[j], "Doc_Entries");
                    
                    // Only process if there's an archive linked to the document
                    if (documentInfo) {
                        archivalid = documentInfo[ARDID];
                    }
                    // Get archival signature from archival documents data
                    if (archivalid) {
                        let archivalInfo = findInfo(archivalid, "Archival_Docs");
                        let archive = archivalInfo[ARDARC];
                        let fond = archivalInfo[ARDARCFOND];
                        let signature = archivalInfo[ARDSIG];

                        if (archive && j == 0){
                            archiveprocessed += `<br><b>Archival Document:</b> ${archive}`;
                        } else if (archive) {
                            archiveprocessed += `; ${archive}`;
                        }

                        if (archive && fond){
                            archiveprocessed += `, ${fond}`;
                        }

                        if (archive && fond && signature){
                            archiveprocessed += ` ${signature}`;
                        }
                    }
                }
            }

            // Get coordinates
            coordinates = locationInfo[COORD];
            if (coordinates !== undefined) {
                // Convert the comma-separated string into an array
                let coordsArray = coordinates.split(',').map(Number);

                // Ensure coordinates are in the format [longitude, latitude]
                if (coordsArray.length === 2 && !isNaN(coordsArray[0]) && !isNaN(coordsArray[1])) {
                    // Swap latitude and longitude
                    coordinatesprocessed = [coordsArray[1], coordsArray[0]];

                    const geoJsonFeature = {
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: coordinatesprocessed // Ensure this is [longitude, latitude]
                        },
                        properties: {
                            popupContent: description ? 
                                `<b>Person:</b> ${personprocessed}<br><b>Date:</b> ${daterange}<br> <b>Place:</b> ${locationprocessed} <br><b>Description:</b> ${description} ${archiveprocessed}` : 
                                `<b>Person:</b> ${personprocessed}<br><b>Date:</b> ${daterange}<br> <b>Place:</b> ${locationprocessed} ${archiveprocessed}`
                        }
                    };

                    const geojsonMarkerOptions = {
                        radius: 5,
                        fillColor: "#0c8aff", //black fill color
                        color: "#000000", //Black border color
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    };

                    let marker = L.geoJson(geoJsonFeature, {
                        pointToLayer: function (feature, latlng) {
                            return L.circleMarker(latlng, geojsonMarkerOptions);
                        }
                    }).bindPopup(geoJsonFeature.properties.popupContent);

                    markers.push({ marker, personID: person, text: `[${daterange}] ${personprocessed}: ${description}` });
                } else {
                    console.warn('Invalid coordinates:', coordsArray);
                    continue;
                }
            } else {
                continue;
            }
            // Reset variables
            person = "";
            personprocessed = "";
            locationid = "";
            locationprocessed = "";
            largerlocation = "";
            daterange = "";
            coordinates = "";
            coordinatesprocessed = "";
            description = "";
            docentry = "";
            bibliography = "";
            archiveprocessed = "";
        }
    }

    // Apply the initial filter
    filterMarkers();
}

// Function to filter markers based on checkboxes
function filterMarkers() {
    console.time()

    // Fetch checkbox states
    let showComposers = document.querySelector("#composer-select").checked;
    let showMusicians = document.querySelector("#musician-select").checked;
    let showNonMusicians = document.querySelector("#non-musician-select").checked;

    // Loop through all markers and show/hide based on checkboxes
    markers.forEach(({ marker, personID }) => {
        let type = personID.substring(0, 3);
        let show = false;

        // Determine if the marker should be shown based on checkbox states
        if (type === "BCO" && showComposers) {
            show = true;
        } else if (type === "BMU" && showMusicians) {
            show = true;
        } else if (type === "BNO" && showNonMusicians) {
            show = true;
        }

        // Add or remove marker from map based on show status
        if (show) {
            if (!map.hasLayer(marker)) {
                marker.addTo(map);
            }
        } else {
            if (map.hasLayer(marker)) {
                map.removeLayer(marker);
            }
        }
    });
    
    // Ensure map is refreshed to reflect changes
    map.invalidateSize();

    // After filtering by checkboxes, apply search filter
    UserSearch(true);

    console.timeEnd()
}


//////////////////////////////
//
// UserSearch –-
//

function UserSearch(skipFilter = false) {
    let input = document.querySelector("#input");
    let regex = new RegExp(input.value, 'i');
    let searchCount = 0;

    // Fetch checkbox states
    let showComposers = document.querySelector("#composer-select").checked;
    let showMusicians = document.querySelector("#musician-select").checked;
    let showNonMusicians = document.querySelector("#non-musician-select").checked;

    // Loop through all markers and show/hide based on search query and checkbox states
    markers.forEach(({ marker, text, personID }) => {
        let type = personID.substring(0, 3);
        let show = false;

        // Determine if the marker should be shown based on checkbox states
        if (type === "BCO" && showComposers) {
            show = true;
        } else if (type === "BMU" && showMusicians) {
            show = true;
        } else if (type === "BNO" && showNonMusicians) {
            show = true;
        }

        // Add or remove marker from map based on search query and checkbox states
        if (text.match(regex) && show) {
            if (!map.hasLayer(marker)) {
                marker.addTo(map);
            }
            searchCount++;
        } else {
            if (map.hasLayer(marker)) {
                map.removeLayer(marker);
            }
        }
    });

    let searchString = searchCount === 1 ? `[${searchCount} event]` : `[${searchCount} events]`;
    let searchStringElement = document.querySelector("#search-count");
    if (searchStringElement) {
        searchStringElement.innerHTML = searchString;
    }

    // If the function is called from filterMarkers, no need to re-filter by checkboxes
    if (!skipFilter) {
        filterMarkers();
    }
}

</script>